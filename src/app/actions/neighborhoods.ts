'use server';

import { getAdminDb } from '@/lib/firebase-admin';
import * as admin from 'firebase-admin';

// Helper to normalize strings for comparison (e.g., "St. Pauli" -> "stpauli")
function normalize(str: string) {
    return str.toLowerCase().replace(/[^a-z0-9]/g, '');
}

export async function registerNeighborhood(neighborhoodName: string, userId: string) {
    if (!neighborhoodName || !neighborhoodName.trim()) {
        return { success: false, error: "El nombre del barrio es obligatorio." };
    }

    const db = getAdminDb();
    const cleanName = neighborhoodName.trim();
    const normalizedName = normalize(cleanName);

    try {
        // --- PASO A: Verificación Interna (Firestore) ---
        // Check if explicitly exists in 'neighborhoods' collection
        // We assume the ID is the normalized name or we query by a field 'normalizedName'
        const neighborhoodsRef = db.collection('neighborhoods');
        const q = neighborhoodsRef.where('normalizedName', '==', normalizedName).limit(1);
        const snapshot = await q.get();

        if (!snapshot.empty) {
            // Already exists
            const existing = snapshot.docs[0].data();
            return {
                success: true,
                exists: true,
                slug: existing.slug || existing.id || displayToSlug(existing.name),
                message: "¡Este barrio ya existe!"
            };
        }

        // --- PASO B: Verificación Externa (Google Places API) ---
        const googleApiKey = process.env.GOOGLE_MAPS_API_KEY || process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY || process.env.NEXT_PUBLIC_FIREBASE_API_KEY;
        if (!googleApiKey) {
            console.error("Missing GOOGLE_MAPS_API_KEY");
            return { success: false, error: "Error de configuración del sistema (API Key)." };
        }

        // https://developers.google.com/maps/documentation/places/web-service/search-text
        const searchUrl = `https://maps.googleapis.com/maps/api/place/textsearch/json?query=${encodeURIComponent(cleanName)}&key=${googleApiKey}`;

        const googleRes = await fetch(searchUrl);
        const googleData = await googleRes.json();

        if (googleData.status !== 'OK' && googleData.status !== 'ZERO_RESULTS') {
            console.error("Google Places API Error:", googleData);
            return { success: false, error: "Error al verificar con Google Maps." };
        }

        // Filter for valid types
        const validTypes = ['neighborhood', 'sublocality', 'political', 'sublocality_level_1'];
        const validPlace = googleData.results?.find((place: any) =>
            place.types.some((t: string) => validTypes.includes(t))
        );

        if (!validPlace) {
            return {
                success: false,
                error: "No hemos podido verificar que este barrio exista realmente. Por favor revisa el nombre."
            };
        }

        // --- PASO C: Detalles y Jerarquía (Nuevo con processDiciloPlace) ---
        // 1. Fetch Details to get explicit address components
        const placeId = validPlace.place_id;
        const detailsUrl = `https://maps.googleapis.com/maps/api/place/details/json?place_id=${placeId}&fields=name,geometry,address_components,place_id,formatted_address&key=${googleApiKey}`;

        const detailsRes = await fetch(detailsUrl);
        const detailsData = await detailsRes.json();

        if (detailsData.status !== 'OK') {
            console.error("Google Place Details Error:", detailsData);
            return { success: false, error: "Error obteniendo detalles del lugar." };
        }

        const placeDetails = detailsData.result;

        // 2. Parse using standardized utility
        const { processDiciloPlace } = await import('@/lib/place-utils');
        const processed = processDiciloPlace(placeDetails);

        if (!processed) {
            return { success: false, error: "No se pudo procesar la ubicación correctamente." };
        }

        const officialName = processed.name;
        // Use normalized name or slug as ID. 
        // Existing logic used displayToSlug. Let's keep that but ensure uniqueness?
        // Actually, let's stick to slug based on name for clean URLs
        const newSlug = displayToSlug(officialName);

        const newDocRef = neighborhoodsRef.doc(newSlug);

        await newDocRef.set({
            name: officialName,
            slug: newSlug,
            normalizedName: normalize(officialName),
            city: processed.hierarchy.city || 'Hamburg',
            country: processed.hierarchy.country,
            type: processed.type, // 'barrio' | 'ciudad'
            hierarchy: processed.hierarchy,
            location: processed.coordinates,
            placeId: processed.placeId,
            formattedAddress: validPlace.formatted_address,
            createdBy: userId,
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            status: 'active',
            isAutoGenerated: true
        });

        return {
            success: true,
            created: true,
            slug: newSlug,
            name: officialName,
            type: processed.type,
            hierarchy: processed.hierarchy,
            message: `¡${officialName} registrado exitosamente!`
        };

    } catch (error: any) {
        console.error("Error registering neighborhood:", error);
        return { success: false, error: "Error interno del servidor." };
    }
}

function displayToSlug(text: string) {
    return text
        .toLowerCase()
        .replace(/[^\w ]+/g, '')
        .replace(/ +/g, '-');
}

function parseCityFromAddress(address: string): string {
    // Basic heuristics for City. Google Address Components would be better but require details fetch
    // Ensure we default to something reasonable if not found.
    // Address format usually: "Neighborhood, City, Country" or "Neighborhood, City"
    if (!address) return '';
    const parts = address.split(',');
    if (parts.length >= 2) {
        // Return the second to last p art usually contains city/zip
        // This is fuzzy. For "Hamburg", usually simply "Hamburg" works.
        // Let's rely on basic string check or return the input as fallback
        if (address.includes('Hamburg')) return 'Hamburg';
        if (address.includes('Berlin')) return 'Berlin';
        return parts[parts.length - 2].trim().replace(/[0-9]/g, '').trim(); // Remove zip codes
    }
    return 'Hamburg'; // Default fallback as per user context predominant city
}
